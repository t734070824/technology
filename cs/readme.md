## 深入理解计算机系统

### 概述
1. 区分不同数据对象的唯一方法 --> 读到这些数据对象时的上下文(这一句话 就值得看了..)
    - 有点 取地址执行 的意思了...
2. C语言很优秀, 但是由于缺乏 对抽象的支持(类, 对象, 异常), 导致 c++, java的出现
    - 朝着 使用更加方便 的方向 前进,,,
3. 程序 是被其他程序翻译成不同的格式
4. 高速缓存的局部性原理--> 程序具有访问局部区域里的数据和代码的趋势
    - LRU?
    - 存放可能经常访问的数据
5. 存储器的层级结构
    - ![](photo/Snipaste_2021-06-10_10-54-10.png)
6. 流水线
    - 一个指令分为多各阶段
    - 一个流水线 只是 专注处理各个阶段中的一个极端
    - 当前流水线完成了, 交给下一个流水线
    - 多个流水线 并行执行
7. 操作系统管理硬件
    - 两个基本功能: 1. 防止滥用 2. 提高简单一致的抽象来控制复杂的不尽相同的硬件设备(简单使用) --> 抽象
    - 基本的抽象: 进程, 虚拟内存, 文件
        - 文件: IO设备的抽象
        - 虚拟内存: 主存和硬盘IO设备的抽象(程序存储器)
        - 进程: 处理器, 主存和IO设备的抽象(正在运行的程序)
        - 这三个的抽象表示有点一次, 有点 层层包含的意思啊...
8. gcc
    - gun Compiler Collection  编译套件
    - 过程: 预处理器, 编译器, 汇编器, 链接器
        - 有网络分层内味了
9. shell
    - 她是如何识别你的命令是一个 内置的shell命令 还是 一个可执行文件的名字
    - 看起来是名字匹配了
10. 硬件组成
    - ![](photo/硬件组成.png)
    - cpu: 解释/执行存储在主存中指令的引擎
11. DMA: 直接存储器存取
12. 高速缓存
    - 主要解决 处理器速度和主存 硬盘速度的差异的问题
13. 进程
    - 从进程的角度看, 自己觉得自己使用完整的计算机资源
    - 多个进程就会存在 上下文切换
        - **保存当前进程的上下文, 恢复新进程的上下午** --- 666
        - 进程控制块(process control block，**PCB**)的数据结构存储起来。
    - 此时--锁定cpu...
    - 虚拟地址空间
        - 每个进程看到的内存都是一致的
        - 那么是不是 在各自看的内存中, 也要分区的啊
        - 分布
            - 程序代码和数据: 所有进程都是从同一个固定地址开始的; **代码和数据区是直接按照可执行目标文件的内容初始化**
            - 堆: 运行时堆; mallor free这样的 C标准函数时, 可以运行时动态的伸缩
            - 共享库: 共享库的代码和数据
            - 栈: **编译器用它实现函数调用**; 在程序执行期间动态的伸缩
            - 内核虚拟内存: 为内核保留,
        - 仔细看看, 这个java虚拟机的内存分配
        - ![](photo/进程的虚拟地址空间.png)
14. 计算机的抽象
    - ![](photo/计算机的抽象.png)

### 信息的表示和处理
1. 使编写的程序能在全部数值范围内正确工作, 并具有可以跨越不同机器 操作系统 和 编译器组合的 可移植性
    - 很NB
2. 程序对象: 程序数据 , 指令, 控制信息....
3. 解释的作用
    - 关键还在与如何解释, 针对同一个数据 有不同的解释, 那么就有不同的意义
4. 字数据
    - 字长: word size, 字长为W, 那么 虚拟地址的范围就是 0 -- 2^w-1
    - 有点总线位数的意思了
    - C语言: 数据类型的确切字节数 依赖 程序是如何被编译的: **gcc -m32 prog.c** vs **gcc -m64 prog.c**
5. 程序的可移植性
    - 为什么要考虑这个: 同一个数据类型可能在不同系统中 有不同的大小\
    - 那么就要程序 对 不同数据类型的确切大小不敏感 :
        - C: int32_t(4个字节) int64_t(8个字节) 在 32位和64位 大小都一样
        - java:

### 程序的机器级表示
1.

### 依赖


### 遇到的问题


### 具体 步骤


### 步骤

### 为什么要看这本书
1. 为了 理解 -> Linux内核


### 思考
